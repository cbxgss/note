# 1绪论

## 1.1程序设计语言的发展

-   低级语言
    -   机器语言
    -   汇编语言
-   高级语言
    -   面向用户的语言
    -   面向问题的语言

## 1.2基本概念

-   程序
    -   **源程序**
    -   **目标程序**: 用**目标语言**表示的程序
        -   **目标语言**: 可以是源语言和机器语言之间的中间语言，可以是机器语言，也可以是汇编语言

    -   **翻译程序**: 源程序 -> 目标程序 的转换程序，包括如下等变换程序
        -   **编译程序**: 高级语言 -> 目标程序 的翻译程序
        -   **汇编程序**: asm -> elf 的翻译程序


-   **编译和解释**

    -   编译程序: 以一个可执行程序的描述作为输入，以另一个等价的可执行程序的描述作为输出
    -   解释程序: 以一个可执行程序的描述作为输入，以执行这一可执行程序描述的结果作为输出


## 1.3编译程序的结构

-   编译程序总框

    <img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20210925174710523.png" alt="image-20210925174710523" style="zoom:50%;" />

    -   5个阶段都需要做以下两件事
        -   建表和查表 (**符号表管理**)
        -   **出错处理**

    <img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20211109105740488.png" alt="image-20211109105740488" style="zoom: 33%;" />

    -   **编译前端**

        -   **词法分析器**(扫描器): 输入源程序，进行词法分析，输出单词符号

        -   **语法分析器**(分析器): 对单词符号串进行语法分析，根据语法规则进行推导或归约，识别出各类语法单位，最终判断输入串是否构成语法上正确的程序

        -   **语义分析和中间代码产生器**: 按语义规则对语法单位进行语义分析并翻译成一定形式的中间代码

    -   **编译后端**

        -   **优化器**: 对中间代码进行优化处理

        -   **目标代码生成器**: 把中间代码翻译成目标程序

-   编译器的**基本原则**

    -   不违背原义
    -   实用性原则
-   **遍** PASS
    -   **遍**: 对源程序或中间结果从头到尾扫描一次
    -   编译程序
        -   上面的5个阶段只是逻辑上的划分
        -   真实的编译程序往往被组织为几个**遍**
        -   **一遍扫描编译程序**: 不是所有语言都可以

# 2高级语言及其语法描述

## 2.1程序语言的定义

-   **语法**: 一组规则，用它可以形成和产生一个合式的程序，两部分
    -   **词法规则**: 规定了字母表中哪样的字符串是一个单词符号
    -   **语法规则**(**产生规则**): 规定了如何从单词符号形成语法单位
-   **语义**
    -   一组规则，用它可以定义一个程序的意义

## 2.2高级语言一般特性

-   高级语言的程序结构

    <img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20211109111228686.png" alt="image-20211109111228686" style="zoom: 50%;" />

-   **高级语言的分类**

    -   **强制式语言**: 一系列语句顺序执行，eg: C
    -   **应用式语言**: 更注重函数的功能，`f1(f2(f3(...)))`
    -   **基于规则的语言**: 检查一定的条件，满足时执行适当的动作
    -   **面向对象语言**: 封装、继承、多态

-   **数据类型与操作**

    -   数据类型三要素
        -   用于区别其他数据类型的属性
        -   可以具有的值
        -   数据对象的操作
    -   分类
        -   初等数据类型: 数值数据，逻辑数据，字符数据，指针类型
        -   数据结构: 数组，记录，字符串、表格、栈、队列，抽象数据类型

-   **语句与控制结构**

    -   表达式
    -   语句
        -   赋值语句
        -   控制语句
        -   说明语句
        -   简单句和符合句

## 2.3程序语言的语法描述: 文法

-   一些概念
    -   符号相关
        -   符号: $a, b, c$
        -   字母表: 符号的非空有限集 $\sum = \{a, b, c\}$
        -   符号串
            -   空符号串: $\epsilon$
    -   终结相关
        -   非终结符: $A, B, C$
        -   终结符: $a, b, c$
        -   终结符或非终结符: $X, Y, Z$
        -   终结符号串: $w, x, y, z$
        -   终结符或非终结符构成的符号串: $\alpha, \beta$
    -   产生式
        -   $A \rightarrow \alpha$
        -   $A \rightarrow \alpha_1|...|\alpha_n$
    -   符号串的运算

-   **文法**直观概念

    -   文法: 对语言结构的定义与描述
    -   **语法规则**: $<句子>::=<主语><谓语>$
    -   **推导**: $<句子> \Rightarrow <主语><谓语>$

-   **文法**形式化定义

    -   $G=(V_N, V_T, P, S)$ (非终结符，终结符，规则，起始符号)

    -   **推导**

        |              推导               |     意义      |
        | :-----------------------------: | :-----------: |
        | $\mathop{\Rightarrow}\limits_G$ |   一步推导    |
        | $\mathop{\Rightarrow}\limits^+$ |   多步推导    |
        | $\mathop{\Rightarrow}\limits^*$ | 0步或多步推导 |
        
        -   推导方式: 多个非终结符时

            -   **最左推导**
        -   **最右推导** (**规范推导**)

-   句型和句子

    -   **句型**: 设 $G$ 是一个文法，$S$ 是起始符号，$S=>^*x$，则 $x$ 是 $G$ 的句型 (用规范推导得到的句型为规范推导)
    -   **句子**: 如果 $x$ 里只有终结符号
    -   **语言**: 集合 $L(G) = \{x|S=>^*x且x \in V_T^*\}$，即所有句子
    -   **文法等价**: 若 $L(G1)=L(G2)$

-   **文法的类型**

    |  类型   | 别名           |            对任一产生式$\alpha \rightarrow \beta$            | 识别系统           |
    | :-----: | -------------- | :----------------------------------------------------------: | ------------------ |
    | 0型文法 | 短语文法       | $\alpha \in (V_N \bigcup V_T)^+$，$\beta \in (V_N \bigcup V_T)^*$ | 递归可枚举         |
    | 1型文法 | 上下文有关文法 |   $|\alpha|<=|\beta|$ ($\alpha \rightarrow \epsilon$除外)    | 线性界限自动机     |
    | 2型文法 | 上下文无关文法 |      $\alpha \in V_N$，$\beta \in (V_N \bigcup V_T)^*$       | 不确定的下推自动机 |
    | 3型文法 | 正则文法       | 形式都为 $A \rightarrow aB$ 或 $A \rightarrow a$，其中 $A \in V_N, B\in V_N, a \in V_T$<br />又叫右线性文法，另外有左线性文法和其等价 | 有穷自动机FA       |

    -   **上下文无关文法**: 有足够能力描述现今程序设计语言的语法结构

-   **语法分析树(语法树)**: 用于描述上下文无关文法的**句型推导**

    <img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20210928183920621.png" alt="image-20210928183920621" style="zoom:50%;" />

-   **文法的二义性**

    -   一个句子对应两颗不同的语法树 或 一个句子有**两个不同的最左(右)推导**

        <img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20210928184509202.png" alt="image-20210928184509202" style="zoom:50%;" />

    -   部分二义文法可以改造为无二义文法

        -   规定优先顺序(T)和结合律(左递归)

# 3词法分析

## 3.1词法分析器的作用

![image-20210928194559182](%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20210928194559182.png)

-   从左到右逐字**对源程序扫描**，**产生单词符号**，根据词法规则识别及组合单词，进行词法检查
    -   对数字常数`atoi`
    -   删除空格和注释
-   **单词符号**

    -   分类
        -   关键字(保留字)
        -   标识符
        -   常数
        -   运算符
        -   界符(`/* ,`等)

    -   形式: **(单词种别，单词符号的属性值)**
        -   **单词种别**: 整数编码

<img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20211109161334463.png" alt="image-20211109161334463" style="zoom: 33%;" />

-   词法分析可以单独一遍，也可以作为**单独的子程序** (效率高)

## 3.2状态图(词法分析器的设计)

-   **输入、预处理**

    <img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20211109162219194.png" alt="image-20211109162219194" style="zoom:50%;" />

    -   **输入缓冲区**: 把输入串放在一个缓冲区里
    -   **预处理子程序**: eg: 去掉编辑性字符等
    -   **扫描缓冲区**: 每当词法分析器调用 预处理子程序，就输入一串字符，装入 扫描缓冲区
    -   对扫描缓冲区进行扫描时一般用两个指示器
        -   **起点指示器**: 正在识别的单词的开始位置
        -   **搜索指示器**: 用于前向搜索以寻找单词的终点

-   **单词的识别**(**超前搜索**)

    -   关键字的识别
    -   标识符的识别
    -   常数的识别
    -   算符和界符的识别

-   **状态转换图**

## 3.3正则表达式与FA

-   正则表达式 和 正则文法

    -   正则表达式 $\rightarrow$ 正则文法

        <img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20211119195207720.png" alt="image-20211119195207720" style="zoom: 67%;" />

        <img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20211119195814759.png" alt="image-20211119195814759" style="zoom: 67%;" />

    -   正则文法 $\rightarrow$ 正则表达式

        <img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20211119195218968.png" alt="image-20211119195218968" style="zoom:50%;" />

-   $DFA$ 和 $NFA$

    -   $NFA$ 确定化

    -   $DFA$ 最小化

        -   最小 $DFA$

            -   没有死状态！（和自动机课上学的不同）
            -   没有等价状态，可区别的状态不满足下面两条：
                -   都是终态或非终态
                -   从状态 $s$ 和 $t$ 出发，读入某个字符串，到达的状态等价


            <img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20211119200718157.png" alt="image-20211119200718157" style="zoom: 80%;" />

            <img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20211119200921454.png" alt="image-20211119200921454" style="zoom: 67%;" />

-   正则文法和NFA

-   正则表达式和NFA

    -   NFA $\rightarrow$ 正则表达式

        <img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20211119201557997.png" alt="image-20211119201557997" style="zoom: 67%;" />

    -   正则表达式 $\rightarrow$ NFA

        <img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20211119201635403.png" alt="image-20211119201635403" style="zoom: 67%;" />

        <img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20211119201651427.png" alt="image-20211119201651427" style="zoom:50%;" />


## 3.4词法分析程序的自动生成

-   **LEX	**

    -   作用

        ```mermaid
        graph LR
        	1[LEX编译程序]
        	0--LEX源程序-->1
        	1--词法分析器L-->2
        ```

        ```mermaid
        graph LR
        	1[词法分析器L]
        	0--输入串-->1
        	1--单词符号串token流-->2
        ```

    -   组成

        -   **正规定义式**
            -   一堆 $d_i \rightarrow r_i$
                -   $d_i$: 不同的名字(eg: `digit`)
                -   $r_i$: 正则表达式 (eg: `0|1|...|9`)
            -   $r_i$ 里不能含有 $d_i, d_i+1, ...$，否则会出循环
        -   **识别规则**
            -   一堆 $P(i)$   $\{A_i \}$
            -   $P(i)$: **词形**: 正规式或其名字
            -   $A_i$: 一小段代码，识别后采取的动作，表示成`return(code, value)`
                -   `code`: 种类编码
                -   `value`: 有的种类用，属性值

    -   实现
        -   对每个 $P_i$，构造一个 $NFA$
        -   创建一个新的起始状态，合并 $NFA$，得到新的 $NFA$
        -   变成 $DFA$，并最小化
        
        <img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20211119201814563.png" alt="image-20211119201814563" style="zoom:50%;" />

-   **最长匹配原则**: 用 $DFA$ 识别时，应用最长匹配原则: 到达一个终态时，先看看有无进一步的转换

-   **优先匹配原则**: 两个规则同时满足时，用前面的

-   举例

    <img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20211119220503505.png" alt="image-20211119220503505" style="zoom:50%;" />

    <img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20211119220516286.png" alt="image-20211119220516286" style="zoom:50%;" />

    <img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20211110101606600.png" alt="image-20211110101606600" style="zoom:50%;" />
    
    <img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20211110101629414.png" alt="image-20211110101629414" style="zoom:50%;" />
    
    <img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20211110101745991.png" alt="image-20211110101745991" style="zoom:50%;" />

# 4语法分析

## 4.1语法分析器的功能

-   以语法分析器为核心的编译器模型

    ![image-20211019203709937](%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20211019203709937.png)

-   作用
    -   接受**词法分析器**提供的**记号串**
    -   检查**记号串**是否能由源程序语言的**文法**产生
    -   用易于理解的方式提示语法**错误**信息，并能从常见的错误中恢复

-   分类
    -   通用的语法分析方法
    -   编译器使用的语法分析方法
        -   **自顶向下** **LL文法**: 分析器常手工实现
        -   **自底向上** **LR文法**: 分析器常利用自动生成工具
        -   第一个L: **最左推导**

## 4.2自顶向下分析

### 概述

-   分类
    -   **回溯分析**: 一个一个产生式得试，不行就回溯换
    -   **预测分析**: 不用回溯(**递归向下分析**) $LL(k)$: 向前固定多看k个输入符号

-   问题

    -   **自顶向下分析的**基本缺点**: 不能处理左递归文法**
        -   **直接左递归**: $A \rightarrow A\alpha$ 会造成死循环
        -   **间接左递归**: 多步推导出现
    -   **回溯**: 同一个非终结符的多个候选式，有**共同前缀**
    -   难以分析错误的确切位置


### 消除左递归

-   消除直接左递归

    -   对于$P \rightarrow Pα_1 | Pα_2|...|Pα_m|\beta_1|...|\beta_n$
    -   其实 $P$ 就是一个 $\beta$ 开头，后面是 $*$ 个 $\alpha$ 的字符串
    -   所以可以变为 $P \rightarrow \beta P'$ 和 $P' \Rightarrow \alpha P' | \epsilon$
-   消除间接左递归
    -   产生式带入，产生直接左递归
    -   消除直接左递归
-   一般算法(不含循环推导 $A \mathop {\Rightarrow}\limits^+A$和 $\epsilon-$产生式)
    -   把 $G$ 的非终结符整理成某种顺序 $A_1, A_2, ...$，使得
        -   右边比左边序号大
        -   如果产生间接左递归，带入消除

### 回溯/公共前缀的解决

-   $FIRST(\alpha)$: 可以从 $\alpha$ 推导出的所有串首终结符的集合

    -   若 $\alpha \mathop{\Rightarrow}\limits^* \epsilon$: $\epsilon \in FIRST(\alpha)$

    -   **串首终结符**: 串的第一个符号，并且是终结符

-   计算 $FIRST(A)$

    -   $A$ 是终结符: $FIRST(A) = \{A\}$
    -   $A$ 是非终结符，且 $A \rightarrow Y_1Y_2...Y_k$: 如果 $Y_1...Y_{i-1} \mathop{\Rightarrow}\limits^* \epsilon$，则 $FIRST(Y_i)$ 加入 $FIRST(A)$
        -   如果 $A \rightarrow \epsilon$，加入 $\epsilon$
    -   如果 $A$ 是符号串: ...

-   **不回溯需要的条件**: $FIRST$ 集合两两不相交

-   解决方法: **提取左因子**

    -   eg: 
        -   $S \Rightarrow aA|aB$
        -   改成: $S \Rightarrow aS'$，$S' \Rightarrow A|B$

    -   本质: 推迟决定，等待足够多的输入
    -   代价: 会引入大量新的非终结符和 $\epsilon$ 产生式

### LL(1)文法定义 / LL(1)条件

-   **不含左递归**
-   **无回溯**: 任意两个左边相同的产生式 $A \rightarrow \alpha | \beta$ 满足
    -   $FIRST(\alpha) \cap FIRST(\beta) = \empty$
    -   若 $\alpha \Rightarrow^* \epsilon$，则 $FIRST(A) \cap FOLLOW(A) = \empty$
    -   若 $\beta \mathop{\Rightarrow}\limits^* \epsilon$，同上
-   非终结符的**后继符号集** $FOLLOW(A)$: 紧跟 $A$ 的终结符的集合
    -   规定: 如果 $A$ 是某个句型的最右符号，则将结束符 $\#$ 加入到 $FOLLOW(A)$
-   计算 $FOLLOW(B)$
    -   把 $\#$ 放入 $FOLLOW(S)$
    -   对 $A \rightarrow \alpha B \beta$，$FIRST(\beta)-\{\epsilon \}$ 加入 $FOLLOW(B)$
    -   对 $A \rightarrow \alpha B$ 或 $A \rightarrow \alpha B \beta$ 且 $\epsilon \in FIRST(\beta)$，$FOLLOW(A)$ 加入 $FOLLOW(B)$
    -   不断用上面两个规则

### LL(1)分析

-   **预测分析表**

    <img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20211110113023592.png" alt="image-20211110113023592" style="zoom:50%;" />

    -   x: 终结符号，有 $\#$，没有 $\epsilon$
    -   y: 非终结符号
    -   内容: 产生式
    -   填法: 对于每个非终结符 $A$(每一行)
        -   把 $FIRST(A)$ 里的终结符的对应产生式填入
        -   如果 $FIRST(A)$ 里有 $\epsilon$，在 $FOLLOW(A)$ 终结符的位置填 $A \rightarrow \epsilon$

-   **错误**的出现及基本做法

    -   出现
        -   栈顶的终结符与当前的输入符号不匹配
        -   非终结符 $A$ 在栈顶。输入符号为 $a$，但分析表这里为空
        
    -   基本做法
        -   如果分析表里面是空，跳过输入符号 $a$
        -   如果分析表里是**同步符号** $synch$，弹出栈顶非终结符
            -   如果是初始状态，不弹出，而是继续读入下一个输入符号
        -   **同步符号的选择**: 把做分析表的没用到的 $FOLLOW$ 集合，也填入分析表，填 $synch$
        
        <img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20211110113258239.png" alt="image-20211110113258239" style="zoom:50%;" />

-   **预测分析程序**

    <img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20211020103529838.png" alt="image-20211020103529838" style="zoom:50%;" />

    -   **分析栈**
        -   底部放一个 $\#$: 相当于输入串的开头也是一个 $\#$
        -   里面开始是 $\# E$，$E$ 是开始符号
        -   比如用产生式 $E \rightarrow AB$，则变成 $\# B A$
        -   pop最上面的
        -   产生式右边的左边后push
        -   输入串右移，则pop最上面的终结符

    <img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20211110113347468.png" alt="image-20211110113347468" style="zoom:50%;" />

## 4.3自底下上分析

### 概述

-   将输入串 w **归约**为 S 的过程
    -   **最左归约**: **最右推导**的逆过程 (最右推导得到的句型是最右句型，也叫**规范句型**)
    -   输入串一边进栈，一边归约
    -   **符号栈**
        -   从 `符号栈 = $`，`输入串 = w$`
        -   变成 `符号栈 = $S`， `输入串 = $`
    
-   中心问题
    -   怎么判断栈顶符号串的可归约性: **可归约串**
        -   **算符优先分析**: 用**最左素短语**
        -   **规范归约分析**: 用**句柄**
    -   以及如何归约
    
-   语法生成器的自动生成器: yacc

-   **移进-归约分析**简述: 自底向上语法分析的通用框架

    ![image-20211102193513188](%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20211102193513188.png)

    -   四种动作
        -   移入
        -   归约
        -   接受
        -   报错
        
    -   **句柄**: 每次归约的符号串
    
    -   每次归约都是**最左归约**
    
    -   任何时刻: 栈内符号串 + 剩余输入 = **规范句型**
    
    -   基本概念
    
        -   $\alpha \beta \delta$ 是一个句型，$S \Rightarrow^* \alpha A \delta$ 且 $A \Rightarrow^+ \beta$
        -   **短语**: $ \beta$ 是句型 $\alpha \beta \delta$ 相对于 $A$ 的短语
        -   **直接短语**: 若有 $A \rightarrow \beta$
        -   **句柄**: 最左直接短语
    
        <img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20211119230954044.png" alt="image-20211119230954044" style="zoom:50%;" />
    
        <img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20211102195618664.png" alt="image-20211102195618664" style="zoom:50%;" />
        
        -   都是最右推导

### 算符优先分析法

-   基本概念

    -   **算符文法 OG**: 产生式右边不能是 $\epsilon$ 或 两个相邻的非终结符

    -   **算符优先关系**: 定义终结符之间的优先级关系

        -   $a < b$

            -   有 $A \rightarrow ...aB...$
            -   有 $B \mathop{\Rightarrow}\limits^+ b...$ 或 $B \mathop{\Rightarrow}\limits^+Cb...$
            -   <img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20211110205139312.png" alt="image-20211110205139312" style="zoom: 33%;" />

        -   $a = b$

            -   有 $A \rightarrow ...ab...$ 或 $A \rightarrow ...aBb...$
            -   <img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20211110205238701.png" alt="image-20211110205238701" style="zoom:33%;" />

        -   $a > b$

            -   有 $A \rightarrow ...Bb...$
            -   有 $B \mathop{\Rightarrow}\limits^+ ...a$ 或 $B \mathop{\Rightarrow}\limits^+ ...aC$
            -   <img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20211110205226369.png" alt="image-20211110205226369" style="zoom:33%;" />

        -   **算符优先表**

            <img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20211110203240123.png" alt="image-20211110203240123" style="zoom:50%;" />

    -   **算符优先文法**: 任何一对终结符，都只有上面的一种关系

    -   一个算符优先文法G的任何句型的**最左素短语**是满足下面条件的最左子串 $N_ja_j...N_ia_iN_{i+1}$

        -   $a_{j-1}<a_j$
        -   $a_j=a_{j+1}, ... , a_{i-1}=a_i$
        -   $a_i > a_{i+1}$

-   **找句柄**

    -   从左到右扫描，直到遇到第一个 $>$
    -   向左扫描，跳过所有的 $=$，直到遇到一个 $<$
    -   句柄为 $<$ 和 $>$ 之间

-   **算符优先分析算法**

    -   输入: 输入字符串 $w$ 和优先关系表

    -   思想

        -   如果栈顶终结符 $<$ 或 $=$ 下一个输入符，没找到句柄，语法分析器移动
        -   如果是 $>$，就归约

    -   <img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20211110203717195.png" alt="image-20211110203717195" style="zoom:50%;" />

        -   $E \rightarrow P| E + P$
        -   $P \rightarrow i$

    -   **错误恢复**

        -   能发现的错误
            -   栈顶终结符和当前输入没有优先关系
            -   句柄不是任何产生式的右部
        -   归约时的错误处理
            -   给出错误信息
            -   通过插入、删除来获得句柄
        
        <img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20211110223745657.png" alt="image-20211110223745657" style="zoom:50%;" />

-   **优先函数**
    -   用两个函数 $f()$ 和 $g()$ 来表示算符优先表
        -   若 $a < b$: $f(a) < g(b)$
        -   若 $a = b$: $f(a) = g(b)$
        -   若 $a > b$: $f(a) > g(b)$
    
    -   **算符优先表 $\rightarrow$ 优先函数**(有的可能无法转化)
        -   给每个终结符(包括 $\#$)，创建 $f_a$ 和 $g_a$，以他们为结点，画出 $2n+2$ 个结点
        -   对每个优先关系
            -   如果 $a > b$ 或 $a = b$，画 $f_a \rightarrow g_b$
            -   如果 $a < b$ 或 $a = b$，画 $f_a \leftarrow g_b$
    
        -   结果
            -   如果有环路，则不存在优先函数
            -   如果无环路
                -   $f(a)=从 f_a 开始能到的节点个数$
                -   $g(a) = 从 g_a 开始能到的节点个数$
    
    -   优缺点
        -   优先: 存储空间小
        -   缺点: **原本不能比较的两个字符**，就可以比较了，可能掩盖输入串的错误

### LR分析

-   关键问题: 确定句柄

-   **LR文法**: 最大的、可以构造出相应 移入-归约语法分析器 的文法类

    -   L: 对输入进行从左到右的扫描
    -   R: 最右推导

-   **LR分析器**: **PDA**

    -   **栈**: 存当前状态，状态就包含了输入历史和展望。具体:
        -   状态
        -   已经归约出的文法符号串(其实状态已经有了，为了方便)

    <img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20211116205511911.png" alt="image-20211116205511911" style="zoom: 67%;" />

    -   **LR分析表**

        <img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20211102200812845.png" alt="image-20211102200812845" style="zoom: 33%;" />

        -   $ACTION[s, a]$
            -   $s3$: 移入，然后变成状态3，把原来的状态号入栈
            -   $r1$: 用产生式1归约，把当前状态号出栈
        -   $GOTO[s, X]$: 规定了下一个状态是什么
            -   push状态栈

    -   **LR分析过程**

        -   当前
            -   状态栈: $s_0s_1...s_m$
            -   符号栈: $\#X_1X_2...X_m$
            -   输入串: $a_ia_{i+1}...a_n\#$
        -   即当前状态 $s_m$，考察 $a_i$
        -   分类
            -   $ACTION[s_m, a_i] = sk$
                -   $s_0s_1...s_ms_k$
                -   $\#X1_X2...X_ma_i$
                -   $a_{i+1}...a_n\#$
            -   $ACTION[s_m, a_i] = rk$，其中第 $k$ 个产生式为 $A \rightarrow \beta$，$r = \beta长度$，$s = GOTO[s_{m-r, A}]$，$\beta = X_{m-r+1}...X_m$
                -   $s_0s_1...s_{m-r}s$
                -   $\#X1_X2...X_{m-r}A$
                -   $a_ia_{i+1}...a_n\#$
            -   $ACTION[s_m, a_i] = acc$: 接受
            -   $ACTION[s_m, a_i] = err$: 报错

        <img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20211117104331991.png" alt="image-20211117104331991" style="zoom:80%;" />

        <img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20211117104516953.png" alt="image-20211117104516953" style="zoom:67%;" />

-   构造 LR分析表

    -   LR(0)分析
    -   SLR分析
    -   LR(1)分析
    -   LALR分析

### LR(0)分析

-   **活前缀**: 规范句型的，不含句柄后的任何符号的，前缀

    -   构造一个NFA，识别all活前缀

-   **项目**: 用 圆点 分割 活前缀

    -   项目分类

        -   **移进项目**: $A \rightarrow \alpha * \alpha \beta$
        -   待约项目: $A \rightarrow \alpha * B \beta$
        -   **归约项目**: $A \rightarrow \alpha *$
        -   接受项目: $S' \rightarrow \alpha *$

    -   **项目之间的状态转换**

    -   **等价项目**: 所等待的符号相同

        <img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20211102202602607.png" alt="image-20211102202602607" style="zoom: 50%;" />

        -   当 圆点 右边是非终结符时，出现等价项目

-   **LR(0)自动机**

    -   $\epsilon -CLOSURE(I)$: 给定项目集 $I$ 的闭包，即**等价项目集**，称为**项目集闭包**，**一个项目集闭包对应一个自动机的状态**
        -   $I$: 任一项目集，它的任何项目都属于 $CLOSURE(I)$
        -   若 $A \rightarrow \alpha * B \beta$ 也属于，则 $B \rightarrow * \gamma$ 也属于
        -   重复上面的步骤

    <img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20211102203421096.png" alt="image-20211102203421096" style="zoom:67%;" />

-   **根据转换图得到LR(0)分析表**

    <img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20211102203610855.png" alt="image-20211102203610855" style="zoom: 33%;" />

    -   $GO(I,X)$: 状态转移函数，返回 $I$ 对应于 X 的后继项目集闭包(状态图中，到哪个状态就是几)
        -   $I$: 项目集
        -   $X$: 变元符号
        -   $GO(I,X)=CLOSURE(J)$
            -   $J=\{任何形如A\rightarrow \alpha X * \beta 的项目|A \rightarrow \alpha * X \beta 属于I \}$
    -   $ACTION$
        -   $acc$: $S' \rightarrow S*$ 在这个状态里，把 $\#$ 写 $acc$
        -   $s_j$: 输入某个终结符能到状态 $j$
        -   $r_j$: 归约状态，里面有 $A \rightarrow \alpha *$，则用 $A \rightarrow \alpha$ 归约
        -   $err$: 其他

-   LR(0)分析过程中的冲突

    -   **移进/归约冲突**: 有时一个状态里的项目，有的是归约，有的是待约
    -   **归约/归约冲突**: 两个项目用不同的产生式归约
    -   **CFG不总是 LR(0)文法**

### SLR分析

-   **基本思想**

    <img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20211102205152350.png" alt="image-20211102205152350" style="zoom:50%;" />

    -   项目集内: **移进项目的终结符集合 和 所有归约项目的 $FOLLOW$ 两两不相交**，则可以解决这个项目集的冲突
    -   和 LR(0)分析的区别: 在归约上
        -    LR分析表的归约状态一行都一样
        -   **SLR分析表**的不一定一样
            -   归约项目 $A \rightarrow \alpha*$: $FOLLOW(A)$ 的输入，用该产生式归约
            -   其他与LR相同

-   举例

    <img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20211117142527279.png" alt="image-20211117142527279" style="zoom:50%;" />

    -   $I_1, I_2, I_9$ 有冲突

        <img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/7433F9EF8A96B2DC60AD4F43C543CAF6.jpg" alt="img" style="zoom:33%;" />

    -   <img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20211117143146922.png" alt="image-20211117143146922" style="zoom:80%;" />

-   **SLR分析的冲突**: $b$ 是下一个输入符号，对于 $A \rightarrow a$，$b \in FOLLOW(A)$ 只是归约的一个必要条件，$A$ 的后继符号集合，在特定位置可能会比 FOLLOW 更少

### LR(1)分析

规范LR语法分析

-   **LR(1)项目**: $[A \rightarrow \alpha \cdot \beta, a]$

    -   $a$: $A$ 后面要求紧跟的终结符(**展望符**)
    -   LR(k)的k: 项目的第二个分量的长度

-   **等价LR(1)项目**

    <img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20211102211322204.png" alt="image-20211102211322204" style="zoom:50%;" />

    -   $\beta = \empty$: $b \in FIRST(a)$，即继承展望符
    -   $\beta \neq \empty$: $b \in FIRST(\beta)$

-   **LR(1)自动机**

    ![image-20211102212352984](%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20211102212352984.png)

-   **LR(1)分析表**

    -   就是把SLR的 $FOLLOW$ 改成了LR(1)项目的第二项
        -   归约项目 $A \rightarrow \alpha *, a$: 对于 $a$ 的输入，用该产生式归约

-   **同心项目集**: 除了展望符外，两个项目集相同

### LALR分析(1)

-   目的: 减少LR(1)的状态数

-   将同心项目集中满足ACTION不冲突(将栈顶同样的符号归约为同样的符号)的项目集合并

-   特点

    -   分析能力介于LR(1)和SLR之间
    -   形式上与LR(1)相同
    -   大小上与LR(0)/SLR相当

-   结果

    -   合并时可能出现**归约-归约冲突**，不会产生移进-归约冲突

        ![image-20211102213746404](%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20211102213746404.png)

    -   可能会推迟错误的发现，但出现错误的位置还是准确的

-   LR语法分析表的压缩

### 二义性文法的应用

-   **二义性文法不是LR文法**
-   <img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20211117151313268.png" alt="image-20211117151313268" style="zoom:50%;" />
    -   上面的文法的优势
        -   定义运算的优先级与文法无关，用规则在最后解决冲突
            -   不改状态图的构建
            -   只需要改分析表
        -   状态少



-   LL(1)文法条件
    -   无左递归
    -   无回溯（first，follow(有空时))
-   SLR条件
    -   $I_0$ 中既有移进项目和归约项目时……
