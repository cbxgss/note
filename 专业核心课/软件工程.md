# 引论

-   当前软件产业的趋势
    -   网络化
    -   服务化
    -   全球化

# 1 软件与软件工程

## 1.1 软件是什么

-   <span id="软件的概念">**软件的概念**</span>
    
    -   软件是计算机系统中与硬件相互依存的另一部分逻辑产品
    -   软件是能够完成预定功能和性能并对相应数据进行加工的程序，及其操作的文档
        -   程序 = 算法 + 数据结构
        -   文档 = 自然语言 / 结构化英语 / 图表
        -   数据: 用程序设计语言要求的数据结构表示
    
-   软件分类

-   <span id="软件的特点">**软件的特点**</span>

    -   抽象性: 软件是逻辑实体，没有明显的制造过程，运行和使用没有磨损与老化问题
    -   依存性: 软件开发和运行依赖于计算机系统
    -   工艺性: 软件开发至今尚未完全摆脱手工工艺的开发方式
    -   复杂性: 软件逻辑结构、开发技术、项目管理复杂
    -   成本高: 开发成本、维护成本高
    -   风险大: 软件项目的成功率低
    -   维护难: 维护不能依靠原开发者，理解软件代码难，维护也是开发，维护成本高
    -   软件工作涉及各种社会因素: 政策规章、管理思想、文化背景、信息素养、技术水平、系统接口等

-   <span id="软件发展的四个阶段">**软件发展的阶段**</span>

    ![image-20211113101151665](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211113101151665.png)

    -   早期：专家即用户
        -   面向批处理，有限的分布，自定义软件

    -   第二阶段：程序员（ U-P-C 链）
        -   多用户，实时，数据库，软件产品

    -   第三阶段：复杂化、规模大
        -   分布式系统，嵌入“智能”，低成本硬件，消费者的影响

    -   第四阶段：网络化
        -   强大的桌面系统，面向对象技术，专家系统，人工神经网络，并行计算

-   **软件危机隐现**

    -   <span id="软件危机产生的原因">**软件危机产生的原因**</span>

        -   需求方
        
            -   软件的规模加大、复杂性提高、性能增强
        
            -   需要降低成本，提高开发效率，同时保证质量

            -   用户对软件需求的描述和软件开发人员对需求的理解往往存在差异，用户经常要求修改需求，开发人员很难适应
        
        -   供应方
        
            -   软件是逻辑产品，高密集度的脑力劳动，尚未完全认识其本质和特点
        
            -   技术人员缺乏有效的、系统的开发、维护大型项目的技术手段和管理方法
        
            -   软件开发人员缺乏软件工程化的素质和要求，对工程化的开销认识不足
        
    -   <span id="解决软件危机的方法">**解决软件危机的方法**</span>
        
        -   正确认识“软件”: 软件 ≠ 程序，软件是相关程序、数据及文档的集合。
        -   正确认识“软件开发”: 软件开发不是个体劳动，而主要是一种有组织的团队活动。
        -   研究软件开发的技术手段: 在软件开发中使用已证明行之有效的技术，研究和探索新的技术。更好地使用软件工具，建立一个良好的软件工程支撑环境。
        -   研究软件开发的管理方法: 在软件开发中使用已证明行之有效的工程管理方法。组织良好、管理严密，使各类人员协同配合，共同完成软件开发的工程项目
        -   根本途径
            -   软件工程就是要发展和解放软件的生产力
            -   借鉴工业化模式，通过不断重用，提升技术水平
            -   提高过程管理能力，逐步解决软件危机


## 1.2 软件工程的产生和发展

-   软件工程的发展 的 **四个重要阶段**
    -   **传统的软件工程**: 60年代末70年代为了克服软件危机提出“软件⼯程“名词，将软件开发纳⼊⼯程化的轨道，基本形成了软件⼯程的概念，框架，技术和⽅法。
    -   **对象工程**: 80年代到90年代，⾯向对象的⽅法和技术得到发展，研究重点转移到⾯向对象的分析和设计，演化为⼀种完整的软件开发⽅法和系统的技术体系，称为对象⼯程。
    -   **过程工程**: 80年代中开始，⼈⺠在软件开发实践过程中认识到：提⾼软件⽣产率，保证软件质量关键是“软件过程”，是软件开发和维护中的管理和⽀持能⼒，初步形成了软件过程⼯程。
    -   **构件工程**: 90年代起，基于构件的开发⽅法取得重要进展，软件系统的开发可通过使⽤县城的可复⽤构件组装完成，⽆需从头开始，提⾼效率和质量，降低成本。叫做构件⼯程

## 1.3 软件工程过程与软件生存期

-   **软件工程过程**: 在软件攻击的支持下，所进行的一系列软件开发和进化的活动，包括以下四类基本过程

    -   **软件规格说明**: 规定软件的功能及运行环境
    -   **软件开发**: 产生满足规格说明的软件
    -   **软件确认**: 确认软件能够完成客户提出的要求
    -   **软件演进**: 为满足客户的要求变更

-   软件工程三要素

    -   过程
    -   方法
    -   工具

-   <span id="软件生命周期各阶段及其基本任务">**软件生命周期 SDLC**</span>

    ![image-20211012191016133](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211012191016133.png)
    
    -   软件定义时期 / 计划时期: 总目标的确定，可行性，采用策略，系统功能，所需资源与成本，工程进度表，也称为系统分析时期，分为所定义，可行性研究和需求分析
        -   问题定义
        -   可行性研究
        -   需求分析
    
    -   开发时期: 具体设计和实现前面所定义的软件。分为：总体设计 / 概要设计，详细设计，编码和单元测试，综合（各种）测试，验收测试
        -   总体设计
        -   详细设计
        -   编码和单元测试
        -   综合测试
    
    -   维护时期 / 运行时期: 使软件尽量地满足用户需要，纠错，适应新环境，满足新需求
        -   软件维护
    

## 1.4 软件开发模型

描述软件开发过程中各种活动如何执行的模型

-   初期: <span id="瀑布模型">**瀑布模型**</span>

    <img src="%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20210916103548444.png" alt="image-20210916103548444" style="zoom: 25%;" />

    -   主要思想
        -   软件开发过程与软件生命周期是一致的
        -   相邻二阶段之间存在因果关系
        -   需对阶段性产品进行评审
    -   优点
        -   软件生命周期模型，使软件开发过程可以在分析、设计、编码、测试和维护的框架下进行；每个阶段都会有输出产物
        -   软件开发过程具有系统性、可控性，克服了软件开发的随意性
    -   缺点
        -   项目开始阶段用户很难精确的提出产品需求，由于技术进步，用户对系统深入的理解，修改需求十分普遍。每个阶段都依赖于上一阶段，不能应对客户需求变更。
        -   项目开发晚期才能得到程序的运行版本，这时修改软件需求和开发中的错误代价很大。
        -   采用线性模型组织项目开发经常发生开发小组人员“堵塞状态”，特别是项目的开始和结束。

-   渐进式开发模型: 原型模型、变换模型、增量模型

    -   **增量模型**: 把功能分为多份，一个一个开发
        -   优点
            -   在较短时间内向用户提交可完成部分工作的产品，并分批、逐步地向用户提交产品。从第一个构件交付之日起，用户就能做一些有用的工作
            -   整个软件产品被分解成许多个增量构件，开发人员可以一个构件一个构件地逐步开发。
            -   逐步增加产品功能可以使用户有较充裕的时间学习和适应新产品，从而减少一个全新的软件可能给客户组织带来的冲击
            -   采用增量模型比采用瀑布模型和快速原型模型需要更精心的设计，但在设计阶段多付出的劳动将在维护阶段获得回报
        -   缺点
            -   在把每个新的增量构件集成到现有软件体系结构中时，必须不破坏原来已经开发出的产品。此外，必须把软件的体系结构设计得便于按这种方式进行扩充，向现有产品中加入新构件的过程必须简单、方便，也就是说，软件体系结构必须是开放的。
            -   开发人员既要把软件系统看作整体。又要看成可独立的构件，产生观念上的矛盾。
            -   多个构件并行开发，具有集成的风险。
    -   <span id="原型模型">**原型模型**</span>: 先做一个简易系统，每次把所有功能开发一点，迭代完成
        -   优点
            -   可及早为用户提供有用的产品
            -   可及早发现问题，随时纠正错误
            -   减少技术、应用风险，缩短开发时间，减少费用、提高生产率
            -   通过实际运行原型，提供直接评价系统的方法，促使用户主动参与开发活动，加强了信息反馈，促进各类人员的协调，减少误解，适应需求变化，能有效提高系统质量
        -   缺点
            -   缺乏丰富而强有力的软件工具和开发环境。
            -   缺乏有效的管理机制，还未建立起自己的开发标准。
            -   对设计开发环境要求较高。
            -   在多次重复改变原型的过程中，程序员会感到厌倦。
            -   系统的易变性对测试有一定影响，难于做到彻底测试，更新文档较为困难。
    -   **变换模型**: 一种形式化软件开发方法

-   上述三者的集大成: <span id="螺旋模型">**螺旋模型**</span>

    <img src="%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20210916111038471.png" alt="image-20210916111038471" style="zoom: 33%;" />

    -   每个螺旋周期可 分为4个工作步骤： 
        -   确定目标、方案和限 制条件
        -   评估方案、标识风险和解决风险
        -   开发确认产品
        -   计划下一周期工作
    -   优点
        -   符合人们认识现实世界和软件开发的客观规律
        -   支持软件整个生命周期
        -   保持瀑布模型的系统性、阶段性
        -   利用原型评估降低开发风险
        -   开发者和用户共同参与软件开发，今早发现软件中的错误
        -   不断推出和完善软件版本，有助于需求变化，获取用户需求，加强对需求的理解

-   其他: V模型，喷泉模型，构建模型

    -   V模型: 强调测试贯穿始终
    -   喷泉模型: 面向对象的模型，迭代，无间隙(每相关的两个互相讨论)
    -   构建组装模型: 极大提高软件开发复用性

-   敏捷开发过程与RUP

    -   敏捷开发: 适用于小项目
    -   统一软件开发过程RUP: 基于UML的一种面向对象软件开发模型，迭代思想，重量级软件开发

## 1.5 软件开发方法

-   软件开发方法可分为两类
    -   面向过程的开发方法
    -   面向对象的开发方法
-   结构化方法及瀑布模型
    -   结构化方法的指导思想: 自顶向下、逐步求精
    -   结构化方法的基本原则: 分解与抽象
    -   结构化开发方法的组成
        -   结构化分析方法 SA法
        -   结构化设计方法 SD法
        -   结构化程序设计方法 SP法
-   面向对象方法
    -   四个要点: 对象，类，父类/子类，消息
    -   面向对象开发方法的组成
        -   面向对象分析方法 OOA法
        -   面向对象设计方法 OOD法
        -   面向对象程序设计方法 OOP法

# 3 需求分析基础

## 3.1 需求功能的基本概念

-   **软件需求的重要性**
-   **软件需求的困难**
    -   应用领域的广泛性
    -   非功能性需求建模技术的缺乏
    -   沟通上的困难
-   **软件需求的内容**
    -   **功能需求**
    -   **领域需求**: 由软件系统的应用领域所决定的特有的功能需求，或是对功能的约束
    -   **非功能需求**
-   **需求分析的作用**
    -   定义软件的范围及必须满足的**约束**
    -   确定软件的功能和性能 及 与其他系统成分的**接口**
    -   建立**数据模型、功能模型和行为模型**
    -   最终提供需求**规格说明**，并用于作为评估软件质量的依据

## 3.2 需求工程的活动

-   **获取需求**
    -   **功能需求**: 基本数据维护功能，基本业务功能，数据库管理功能，信息查询功能
    -   **非功能需求**: 系统安全性需求，对系统可用性的需求(方便性)，对系统查询速度的需求，对系统可靠性的需求
    -   **领域需求**
-   **需求分析与建模**
    -   三个层次的工作
        -   **需求分析**
        -   **需求建模**（分为企业建模、功能需求建模和非功能需求建模等）
        -   **需求规格说明**—不同的描述方式
    -   <span id="需求分析常用技术">**需求分析常用技术**</span>
        -   **分解**: 将⼤问题分解为⼩问题，通常是自顶而下，不断细化的过程
        -   **抽象**: 抓住问题的本质特性，从不同抽象层次进行分析，提出解决问题的方案
        -   **多视点**: 从各类开发人员和不同用户的角度考虑问题，才能获得对系统的全面完整的需求
-   **确认需求**
    -   **有效性检查**: 功能需求是否符合用户所提出的需求
    -   **一致性检查**: 系统功能描述及约束是否一致
    -   **完备性检查**: 是否包含所有系统用户的需求和约束
    -   **可检验性检查**: 是否能设计出一组验证方法，确定了检验的标准
-   **进化需求**: 客户的需要总是不断增长的
    -   传统的变化管理: 基本内容包括软件配置、软件基线和变化审查
    -   新的
        -   **软件家族法**
        -   **多视点方法**

## 3.3 <span id="了解常用的需求分析方法">需求分析方法</span>

-   **功能分解方法**
    -   分成子功能
    -   缺点
        -   需要人工完成
        -   无法对描述的准确度验证
        -   难以适应需求的变化
-   **结构化分析SA方法**: 利用图形表达用户需求，使用的手段主要有数据流图、数据字典、结构化语言、判定表以及判定树等
-   **信息建模法**
    -   从数据的角度对现实世界建立系统的信息模型 ,
    -   基本工具是 ER 图
        -   是由实体、属性和关系组成的网络图
        -   E- 实体，是一个或一组对象
        -   R- 关系，实体之间联系或交互作用

-   **面向对象分析方法 OOA**

    -   **功能模型**: 用户和系统之间的交互
    -   **对象模型**: 系统分解成互相协作的分析类，是系统的静态模型
    -   **动态模型**: 通过时序图/协作图描述对象的交互表示对象间如何协作，单个对象的状态变化/动态行为可以通过状态图来表达

## 3.4 <span id="结构化分析方法">结构化分析SA流程</span>

-   **SA思想**
    
    -   **分解**: 把大问题分解成小问题
    -   **抽象**: 先考虑问题最本质的属性，暂把细节略去，以后再逐层添加细节，直至涉及到最详细的内容。用最本质的属性表示一个系统的方法就是“抽象”
    
-   **SA方法**

    -   建立 当前系统具体模型
    -   抽象 当前系统逻辑模型 (分析用户需求，用DFD图描述)
    -   建立 目标系统逻辑模型 (分析系统需求，用DFD图描述)
    -   改进 完善的系统逻辑模型 (修改完善DFD，添加功能)

-   <span id="会画数据流图（DFD），分层数据流图、数据字典">**结构化描述方法**</span>

    -   **分层的数据流图DFD** (Data Flow Diagram)

        -   可以分层: 如 加工 可以细化，做第二层

        -   数据流图**DFD**

            ![image-20210928085838172](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20210928085838172.png)

            -   基本原则
                -   数据守恒与数据封闭原则
                    -   数据守恒: 每个加工 有 输入 + 输出
                    -   数据封闭: 整个系统
                -   加工分解
                    -   自然性
                    -   均匀性
                    -   分解度: 一个加工每次分解最多7个，分解到基本加工为止
                -   子图与父图的平衡: 子图要和父图对应
                -   合理使用文件

            -   **分层数据流图**只是表达了系统的**分解**，还需要**数据词典**和**小说明**对图中的每个**数据和加工**给出解释

    -   **数据词典DD**: 对DFD中包含的**所有元素的定义**的集合，可有以下条目

        -   **数据流**: 列出该数据流的**各组成数据项**
            -   常用符号: =, +, [|], {}, ()
            -   eg: 报名单＝姓名＋单位名＋年龄＋性别＋课程名
        -   **文件**: 列出文件记录的**组成数据流**
            -   eg: 订单文件＝订单编号＋顾客名称＋产品名称＋订货数量＋交货日期
        -   **数据项**: 通常是数据项的**值类型**，允许的**取值范围**
        -   **加工**: 加工小说明，单独列出

    -   **加工说明**: 每个基本加工都必须有一个小说明

        -   **激发条件**
        -   **加工逻辑**: 用户对这个加工的逻辑要求
        -   **优先级**
        -   **执行频率**
        -   **出错处理**

    -   **描述加工逻辑的结构化语言**、**判定表**及**判定树**: 对基本加工说明的三种描述方式

        -   **结构化语言**: 伪代码
        -   **判定表**: 二维表(可以合并条目，用决策树的思想，改变条件框里的顺序)
        -   **判定树**: 决策树

# 4 软件设计基础

## 4.1 软件设计概述

-   **软件设计的目标**: 构造一个**高内聚低耦合**的软件模型
-   **软件设计的标准**

    -   **软件结构的准则**

        ![image-20211012195753765](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211012195753765.png)

        -   深度: 从顶层模块到底层模块的层数
        -   宽度: 控制的总分布
        -   扇出数: 一个模块直接控制下属的模块个数
        -   扇入数: 一个模块的直接上属模块的个数

        一个好的形态准则是: ①顶部宽度小，中部宽度最大，底部次之；在顶部有较高的扇出数，底部有较高的扇入数

    -   **模块化准则**

        -   把软件划分为一个个的模块
        -   需要注意选择分解的最佳模块数
        -   总成本 = 接口成本 + 模块成本

    -   <span id="高内聚低耦合度的含义">**软件独立性准则**</span>

        -   **内聚**: 指模块内部各成分之间相互关联的程度，以高内聚为设计目标。以下内聚类型的内聚性逐渐提高:
            -   巧合性内聚: 模块内部直接几乎没有联系
            -   逻辑内聚: 把几种功能组合在一起，每次给模块一个参数，模块来确定执行哪一种功能
            -   时间内聚: 一个模块完成的功能必须在同一时间内执行，但也只是因为时间关联在一起
            -   过程内聚: 使用流程图设计程序的时候，流程图中的某一部分划分出组成模块
            -   通信内聚: 模块内各部分功能都使用或输出相同的数据 (通常用数据流图定义的)
            -   信息内聚: 模块能完成多个功能，各个功能在同一数据结构上操作，每个功能都有一个唯一的入口点 (好像一个类???)
            -   功能内聚: 一个模块所有成分完成一个功能
        -   **耦合**: 块间的联系，以低耦合为设计目标。以下耦合类型的耦合性逐渐降低:
            -   内容耦合: 一个模块直接访问另一个模块的内容
            -   公共耦合: 一组模块都使用同一个全局数据结构
            -   外部耦合: 一组模块都使用同一个全局简单变量
            -   控制耦合: 一个模块 (用eg标志，开关量) 来控制另一个模块的功能。但数据已经在自己内部了，不同模块之间用接口互相调用
            -   标记耦合: 调用模块和被调用模块之间传递数据结构
            -   数据耦合: 待用模块和被调用模块之间传递数据项参数
            -   非直接耦合: 两个模块没有之间联系，而是通过主模块的控制和调用来实现的

## 4.2 软件架构设计

-   <span id="软件体系结构概念">**软件体系结构概念**</span>

    -   软件体系结构确定了系统的组织结构和拓扑结构 
    -   显示了系统需求和构成系统的元素之间的对应关系 
    -   提供了一些设计决策的基本原理

-   **软件体系结构设计过程的主要活动**

    -   系统分解
    -   控制建模: 建立系统各部分间控制关系的一般模型
    -   模块分解: 将子系统进一步划分为模块

-   <span id="常见软件体系结构">**常见软件体系结构**</span>

    -   **仓库模型(容器模型)**

        ![image-20211012202618107](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211012202618107.png)

        -   一种集中式的模型
        -   各子系统可以直接访问中央数据仓库存储的共享数据
        -   各子系统可以有自己的数据库，子系统之间通过消息传递实现数据交换
        -   子系统之间紧密耦合
        -   优点
            -   共享大数据量的有效方法
            -   子系统不必关心其它的子系统如何使用它所产生的数据
            -   易于将新子系统集成，若新子系统也采用相同规范
        -   缺点
            -   为了共享数据 ,各子系统必须有一致的数据视图 ，不可避免地会影响了整个系统的性能
            -   子系统的改变，使产生的数据结构也可能发生改变
            -   统一的数据库结构(备份、安全、访问控制和恢复的策 )，将影响子系统的效 率 。

    -   **客户机/服务器 CS架构**

        -   一种分布式模型，采用发请求、得结果的模式

        -   客户机: 向服务器发出请求(数据请求、网页请求、文件传输请求等等)

        -   服务器: 响应请求，进行相应的操作，将结果回传给客户机，客户机再将 格式化后的结果呈现给用户

        -   ![image-20211112143300157](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211112143300157.png)

        -   两层客户机/服务器模型

            ![image-20211112143357424](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211112143357424.png)

        -   三级/多级应用模型

            ![image-20211112143437373](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211112143437373.png)

    -   **P2P 分布式对象结构**

        -   “对象(Object)”——提供服务的系统组件
        -   每个对象在逻辑上是平等的，它们可以互相为对方提供所需的服务
        -   提供服务的对象就是服务器，而提出服务请求的对象就是客户
        -   ![image-20211112143722454](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211112143722454.png)
        -   优点
            -   可在系统布署完成后，再具体考虑服务的分布和如何提供服务的问题
            -   具有开放式结构，提供了极好的灵活性和可伸缩性
            -   系统可进⾏动态分配。

    -   **抽象机模型(分层模型)**

        -   通常用于建立子系统的接口模型。每层提供一组服务，每层 定义一个抽象机
        -   eg: 应用层，传输层......
        -   优点：⽀持增量式开发
        -   缺点：系统构成，性能保证较困难

    -   控制模型: 考虑子系统之间的控制流，分为

        -   集中式控制
        -   事件驱动系统(由外部产生的事件来驱动系统)
            -   广播模型
            -   中断驱动的模型


## 4.3 结构化设计SD方法

-   **SD法的两个阶段**

    -   **总体设计**
        -   任务: 解决系统的模块结构
        -   文档: 模块结构图及其模块功能说明
    -   **详细设计**: 对模块图里的每个模块的过程进行描述，常用方式:
        -   伪代码
        -   流程图
        -   N-S图
        -   PAD图

-   **SD法的设计步骤**

    -   <span id="中心变换分析和事务分析">**从DFD图导出初始的模块结构图SC**</span>

        -   中心变换型DFD: 对输入数据进行转换得到输出数据(计算型?)

        -   事务处理型DFD: 有一个事务中心，按加工的结果选择一个输出数据流(switch型?)

            ![image-20211012204743237](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211012204743237.png)

    -   按SD法设计总则，**改进模块结构图**

        -   尽可能建立功能模块: 功能模块应有最强的内聚性
        -   消除重复功能
        -   控制范围: 结构上的特点，包括模块及其所有下属模块
            -   作用范围: 判断所涉及到的模块，功能特点上的
            -   作用范围 需要为 控制范围 的子集
        -   模块的大小适当
        -   除服务性模块外，模块的扇入扇出不要太多

## 4.4 <span id="详细设计工具">详细设计</span>

任务: 开发一个可以直接转换为程序的软件表示

-   **流程图**

-   **结构化流程图(N-S图)**

    <img src="%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211012205708111.png" alt="image-20211012205708111" style="zoom:50%;" />

-   **PAD图(问题分析图)**

    <img src="%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211012205756228.png" alt="image-20211012205756228" style="zoom:50%;" />

-   **PDL语言**

## 4.5 界面设计

-   用户界面的基本类型
    -   菜单
    -   图像
    -   对话框
    -   窗口
-   数据I/O界面设计
    -   尽量减少输入工作量
    -   输入屏幕与输入格式匹配
    -   数据输入的一般规则: 确定输入，交互动作，确定删除，提供反馈

# 5 程序设计语言与编码

## 5.1 程序设计语言的选择

-   程序设计语言的分类
    -   低级语言
        -   机器语言
        -   汇编语言
    -   高级语言
        -   传统的高级语言
        -   通用的结构化程序设计语言
        -   面向对象程序设计语言
-   程序设计语言选择准则
    -   项目的应用领域
    -   软件的执行环境
    -   性能
    -   数据结构的复杂性
    -   软件开发人员的知识水平以及心理因素

## 5.2 结构化程序设计SP

-   <span id="结构化程序设计的主要特点">**结构化程序设计的主要特点**</span>: **基本思想**是自顶向下、逐步求精。它的**基本原则**是功能的分解与抽象
    -   **自顶而下，逐步求精**
        -   这种逐步求精的思想符合⼈类解决复杂问题的普遍规律，从⽽可以显著提⾼软件开发的效率
        -   体现了先全局，后局部、先抽象后具体的⽅法,使开发的程序层次结构清晰，易读、易理解还易验证，因⽽提⾼了程序的质量

    -   **单入口和单出口的控制结构**
        -   结构化的程序是由且仅由顺序、选择、循环三种基本控制结构组成，既保证了程序结构清晰，⼜提⾼了程序代码的可重⽤性

-   <span id="影响程序效率的因素">**影响程序效率的因素**</span>
    -   **算法**对效率的影响: 复杂度
    -   **存储效率**: 操作系统的存储管理方式，直接影响到程序的存储效率
    -   **输入输出效率**: 提高输入 / 输出速度，减少出错率

-   结构化程序设计的原则
    -   使用语言中的顺序、选择、重复等有限的基本控制结构表示程序
    -   选用的控制结构只准许有一个入口和一个出口
    -   程序语句组成容易识别的块(Block)，每块只有一个入口和一个出口
    -   复杂结构应该用基本控制结构进行组合嵌套来实现
    -   严格控制GOTO语句
-   结构化程序设计的步骤
-   软件设计的时间因素优化

## 5.3 程序设计风格

-   代码文件
    -   符号名的命名
    -   注释
-   语句构造方法: 要易读
-   数据说明方法
-   输入输出技术
    -   输入和输出格式尽可能统一
    -   输出信息中应该反映出入的数据
    -   输入和输出尽可能集中安排
-   影响程序效率的因素
    -   算法
    -   存储
    -   输入输出
-   代码审查
    -   程序的版式
    -   文件结构
    -   命名规则
    -   表达式与基本语句

# 6 软件测试

## 6.1 软件测试的基本概念

-   <span id="软件测试的目的和原则">**软件测试的目的和原则**</span>
    -   **目的**: 因为开发工作的前期不可避免地会引入错误，测 试的目的是为了发现和改正错误
    -   **原则**
        -   尽量不由程序设计者进⾏测试
        -   关键是注重测试⽤例的选择
            -   输⼊数据的组成（输⼊数据、预期的输出结果）
            -   既有合理输⼊数据，也有不合理的输⼊数据
            -   用例既能检查应完成的任务，也能检查不应该完成的任务
            -   长期保存测试用例

        -   充分注意测试中的群集现象。

-   软件测试的对象: 软件测试不等于程序测试，应贯穿与软件定义与开发的成哥期间
-   软件测试与软件开发阶段的关系
    -   软件开发过程是自顶向下的过程
    -   测试时自底向上的过程

## 6.2 <span id="利用软件测试技术进行软件测试">软件测试的步骤</span>

-   **螺旋式的软件测试**

    ![image-20211012211517746](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211012211517746.png)

    -   每转一圈，测试的范围加大一次
    -   螺旋中心是**单元测试**: 测试程序的每一个模块
    -   然后是**综合测试**: 测试软件总体结构
    -   然后是**确认(验收)测试**: 测试软件是否满足需求
    -   最后是**系统测试**: 检查软件与系统中其他元素是否协调

-   **单元测试**: 测试模块

    -   测试的依据: 详细设计描述
    -   应对模块内所有**重要的控制路径**设计测试用例
    -   多采用**白盒测试技术**
    -   分类
        -   接口: 个数、属性、量纲等
        -   局部数据结构
        -   独立路径: 应对每一条独立执行路径进行测试
        -   边界条件
        -   出错处理
    -   单元测试过程
        -   为测试模块开发一个驱动模块和几个桩模块
            -   **驱动模块driver**: 临时上层模块
            -   **桩模块stub**: 临时下层模块
    -   单元测试环境

-   **综合测试**: 组装软件的系统测试技术，发现与接口有关的各种错误

    -   **非增量式集成**: 一下合并
    -   **增量式集成**
        -   自顶向下集成 (需要装桩模块)
            -   优点：能够尽早发现系统主控⽅⾯的问题
            -   缺点：⽆法验证桩模块是否完全模拟了下属模块的功能
        -   自底向上集成 (需要驱动模块)
            -   优点：驱动模块较容易编写桩模块，能够尽早查出底层涉及较复杂的算法和实际的I/O模块中的错误
            -   缺点：最后才能发现系统主控⽅⾯的问题
        -   有时混合使⽤两种策略更为有效,上层模块用自顶向下的方法,下层模块⽤⾃底向上的⽅法

-   **确认测试**: 由用户进行一系列测试(虑软件是否满足合同规定的所有功能和 性能,文档资料是否完整、准确,人机界面和其他方面)，主要是**黑盒测试**

    -   $\alpha, \beta$ 测试

-   **系统测试**

    -   恢复测试: 容错能力，出现错误时能在短时间里恢复
    -   安全测试: 对非法侵入的防范能力
    -   强度测试: 在异常的资源配置下运行(eg: 12306)
    -   性能测试

## 6.3 软件测试的分类

-   **白盒测试**: 对程序所有逻辑路径进行测试
-   **黑盒测试**

## 6.4 黑盒白盒测试技术

-   <span id="白盒测试">**白盒测试的设计策略**</span>
    -   **逻辑覆盖法**
        -   语句覆盖
        -   分支(判定)覆盖: 每个分支
        -   条件覆盖: 决定分支里的变量的每个值
        -   判定/条件覆盖
        -   组合条件覆盖: 决定分支里的变量的每个值的组合
    -   **路径测试法**
        -   点覆盖: 所有分支判断
        -   边覆盖: 所有路径
        -   路径覆盖: 所有路径组合
-   <span id="黑盒测试">**黑盒测试**</span>
    -   **等价分类法**
        -   有效等价类: 合理的输入
        -   无效等价类: 不正常的输入
    -   **边界值分析法**
    -   **错误猜测法**
    -   **因果图法**
        -   把输入条件视为“因” ，把输出条件视为 “果”，将黑盒看成是从因到果的网络图
        -   <img src="%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211112160358722.png" alt="image-20211112160358722" style="zoom: 50%;" />
        -   <img src="%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211112160424655.png" alt="image-20211112160424655" style="zoom:50%;" />

# 7 软件维护

## 7.1 软件维护的概念

-   **软件维护的目的**
    -   提高软件的可维护性
    -   减小软件维护所需要的工作量
    -   降低软件系统的总成本
-   <span id="四种维护的类型">**软件维护 的类型**</span>
    -   **纠错性维护**
    -   **适应性维护**: eg操作系统更新
    -   **完善性维护**: 新功能
    -   **预防性维护**

## 7.2 <span id="软件维护的技术有哪几种">软件维护的技术</span>

-   **面向维护的技术**
    -   在软件开发阶段用来减少错误，提高软件**可维护性**(可测试性、可理解性、可修改性)的技术
    -   涉及到软件开发的所有阶段

-   **软件支援技术**
    -   在软件维护阶段用于提高维护工作的效率和质量的技术
    -   主要用到测试阶段的技术
    -   （信息收集、错误原因分析、软件分析与理解、 维护方案评价、代码与文档的修改、修改后的确 认。）

-   软件维护中应注意的问题（谨慎、工具使用）

## 7.3软件维护的管理

## 7.4 软件维护的特性

-   结构化维护与非结构化维护
    -   结构化维护
    -   非结构化维护: 缺乏必要的文档说明，难于确定数据结构、系统接口等特性。维护工作令人生畏，事倍功半
-   软件维护的代价

# 8 面向对象的方法

## 8.1 面向对象方法概述

-   **结构化方法**
    -   总的指导思想: 自顶向下、逐步求精
    -   基本原则: 分解与抽象
-   **面向对象方法4个要点**
    -   认为客观世界是由各种对象组成的，任何事物都是对象，复杂的对象可以由比较简单的对象以某种方式组合而成
    -   把所有对象都划分成各种对象类（类CLASS），每个对象类都定 义了一组数据和一组方法
    -   继承
    -   对象彼此之间仅能通过传递消息互相联系
-   面向对象=对象+类+继承+传递消息
-   <span id="面向对象技术的特点">**面向对象技术的特点**</span>
    -   对软件开发过程所有阶段进行综合考虑。使问题空间与解空间具有一致性 , 降低复杂性
    -   软件生存期各阶段所使用的方法、技术具有高度的连续性，用符合人类认识世界的思维方式来分析、解决问题
    -   将OOA、OOD、OOP有机地集成在⼀起。有利于系统的稳定性
        -   OOA（Object-Oriented Analysis
        -   OOD（Object-Oriented Design）
        -   OOP（Object-Oriented Program）
        -   以对象为中⼼各种构造系统,⽽不是以功能为中⼼,能很好地适应需求变化.

    -   具有良好的可重⽤性: 由于对象所具有的封装性和信息隐蔽，具有很强的独⽴性


## 8.2 <span id="面向对象的基本概念">面向对象的基本概念</span>

-   **对象**
    -   强调模拟现实世界中的概念而不 强调算法
    -   形象表示
        -   是由描述该对象属性的数据，以及可以对这些数据 施加的所有操作封装在一起构成的统一体
        -   黑盒子
    -   定义
        -   具有相同状态的一组操作的集合(从面向对象程序设计角度看待对象)
        -   是对问题域中某个东西的抽象(从信息模拟角度看待对象)
        -   形式化定义: $对象::=<ID, MS, DS, MI>$
            -   ID: 对象的标识
            -   MS: 对象中的操作集合
            -   DS: 对象中的数据结构
            -   MI: 对象的对外接口
-   **类**: 对具 有相同属性和行为的一个或多个对象的描述
-   **实例**: 由某个特定的类所描述的一个具体的对象
-   **消息**: 由三部分组成 eg: MyCirle.show(r)
    -   接受消息的对象 eg: MyCirle
    -   消息选择符 eg: show
    -   零个或多个变元 eg: r
-   **方法**: 对象所能执行的操作，也就是类中定义的服务
-   **属性**: 类中所定义的数据，它是对客观世界中的实体所具有的性 质的抽象
-   **永久对象**: 生存期可以超越程序的执行时 间而长期存在的对象
    -   目前，大多数 OOPL 不支持永久对象，如果一 个对象要长期保存，必须依靠于文件系统或数据库管 理系统实现，程序员需要作对象与文件系统或数据库 之间数据格式的转换，以及保存和恢复所需的操作等 烦琐的工作
    -   为了实现永久对象，使上述烦琐工作由系统自动 完成，需要较强的技术支持；需要一个基于永久对象 管理系统 OMS （ object management system), 能 够描述和处理永久对象的编程语言。


## 8.3 面向对象的高阶概念

-   **封装**
    -   有一个清晰的边界
    -   有明确的接口
    -   受保护的内部实现
-   **继承**
    -   一重继承: 一个父类
    -   多重继承: 多个父类
-   **多态性**
    -   一个父类包含了一个被子类覆盖的方法
    -   通过一个父类的引用值来引用其不同的子类对象
    -   **动态绑定**: 在运行时根据对 象接收的消息动态地确定要连接的服务代码
-   **重载**
    -   函数重载: 根据若干个参数特征不同
    -   运算符重载

## 8.4 几种面向对象的方法

-   **Booth**
    -   步骤
        -   在给定的抽象层次上识别类和对象
        -   识别类和对象的语义
        -   识别类和对象之间的关系
        -   实现类和对象
    -   丰富的符号体系
        -   **类图** (类结构 - 静态视图)
        -   **对象图** (对象结构 - 静态视图)
        -   **状态转移图** (类结构 - 动态视图)
        -   **时态图** (对象结构 - 动态视图)
        -   **模块图** (模块体系结构)
        -   **进程图** (进程体系结构)
-   **OMT**
    -   通过模型来思考问题
    -   **对象模型**: 系统的静态结构
    -   **动态模型**: 系统随时间变化的、行为的、控制的方面
    -   **功能模型**: 系统的功能的方面
-   **Jacobson**: 面向数据结构的软件设计方法
    -   从目标系统的输入、输出数据结构入手，导出程序框架结构，再补充其他细节，得到完整的程序结构图

面向对象软件技术的优点
-   符合人类思维习惯
    -   传统的软件开发过程强调自顶向下
    -   面向对象尽可能接近人们认识世界解决问题的方法和过程
-   稳定性好
    -   传统: 以算法为核心
    -   面向对象: 以对象为核心，功能需求变化时不会引起软件结构的整体变化
-   可重用性好
-   可维护性好

# 9 UML视图与符号

## 9.1 UML的产生与发展

-   <span id="UML概念">**UML 统一建模语言**: 一种基于面向对象的标准的通用图形化建模语言</span>

    -   –                  Unified Modeling Language

        –                  面向对象软件工程使用的统一建模语言

        –                  一种图形化了的语言，主要用图形方式表示

        –                  一种开放的标准

    -   UML的定义包括 UML 语义和 UML 表示法两个部分
        -   **UML语义**: 描述基于UML的精确元模型(meta-model)定义。元模型为UML的所有元素在语法和语义上提供了简单、⼀致、通⽤的定义性说明,使开发者能在语义上取得⼀致,消除了因⼈⽽异的表达⽅法所造成的影响。此外UML还⽀持对元模型的扩展定义。
            UML支持各种类型的语义。如布尔、表达式、列表、阶、名字、坐标、字符串和时间等，还允许⽤户⾃定义类型。
        -   **UML 表示法**: 定义 UML 符号的表示法 , 为开发者或 开发工具使用这些图形符号和文本语法为系统建模提供了标准 。
            -   视图(views)
            -   图(Diagrams)
            -   模型元素(Model elements)
            -   通⽤机制(general mechanism)

-   主要用于软件的分析与设计

-   用定义完善的符号来图形化地展现一个软件系统

## 9.2 UML的体系结构

-   **设计原则**
    -   **模块化**: 把强内聚和弱耦合的原则应用到分组构建包（package）和组织特征成为元类（metaclass）
    -   **分层化**: 两种分层方式
        -   通过包结构分层 将元语言核心构件与用到它们的高层构件区分开
        -   使用一个架构模式 来分离跨越层之间抽象的关注点
    -   **可扩展**: —为特定平台（如J2EE、.NET等）和特定领域（如金融、电信， 宇航等）定义一组新的方言
    -   **可重用**: 通过重用一组细化和弹性化的元模型库来定义UML元模型，同 时还定义了其他架构相关的元模型，如元对象设施（meta object facility， MOF）和公用仓库元模型（common warehouse metamodel，CWM）

-   实体以及实体之间的关系

    ![image-20211026113118208](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211026113118208.png)

-   **视图 (共9种图)**

    -   **用例视图**: 描述需求
    -   **逻辑视图**: 描述系统功能和词汇
    -   **过程视图**: 描述系统性能、可伸缩性和吞吐量
    -   **实现视图**: 描述系统组装和配置管理，对代码的文件和组件进行建模
    -   **部署视图**: 描述系统的拓扑结构、分布、移交和安装

    共9种图

    ![image-20211026113541812](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211026113541812.png)

-   **RUP 统一软件开发过程**: 用例驱动，以体系结构为中心，迭代，增量的软件开发过程

    -   初始阶段: 理解和分析需求，生成用例模型框架
    -   精化阶段: 完成高优先级的用例开发，完善用例模型
    -   构建阶段: 多次迭代，完成不同优先级用例开发
    -   交付阶段: 进行各种功能，性能测试，进行产品化部署

## 9.3 UML的符号

### <span id="针对具体问题设计用例图">用例视图</span>

-   用例图
    -   定义

        -   用例: 是外部行为者所理解的系统功能
        -   用例建模: 描述一个系统应该做什么（功能需求）
        -   用例图: 把系统看作黑盒子，给出用户所感受到的系统行为

    -   **主要元素**: 系统、用例、行为者、用例间的关系

        ![image-20211026114553167](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211026114553167.png)

        -   **系统**: 是一个提供用例的黑盒子，代表系统的方框的边线代表系统的边界，用于划定系统的功能范围，定义了系统的功能

        -   **用例**: 代表某些用户可见的功能 (代表一类功能而不是使用该功能的某个具体实例)

            -   **脚本**: 用例的实例

        -   **行为者**: 指与系统交互的人或其他系统
        -   **通信联系**: 连接行为者和用例的直线，表示两者之间交换信息
        
    -   **用例之间的关系**
    
        ![image-20211026115224522](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211026115224522.png)
    
        -   **扩展关系** \<\<extend\>\>
    
        -   **包含关系** \<\<include\>\>
    
        -   **泛化关系**: 一种继承关系，子类指向父类
    
            ![image-20211014114042083](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211014114042083.png)
    
    -   用例建模
    
        -   确定执行者
        -   确定用例
        -   用例描述
            -   用况名
                -   用况实例: 使用系统的一个特定用况的一条执行路径
                -   用况: 一系列可能的场景集合
            -   参与的执行者
            -   基本路径，可选路径

### 设计视图

-   <span id="针对具体问题设计类图">**类图**</span>

    -   概念: 用户根据用例图抽象成类，描述类的内部结构和类与类之间的关系

    -   <span id="类与类之间的关系">**关系**</span>

        ![image-20211028105059234](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211028105059234.png)

        -   关系强弱顺序: 泛化 = 实现 > 组合 > 聚集 > 关联 > 依赖
        
        -   泛化 / 继承: 子类指向父类

        -   实现: 类指向其接口的实现

        -   聚集: 整体与部分的关系

        -   组合: 更强的整体与部分，整体不在了，部分就没了

        -   依赖: 一种使用的关系(人指向计算机)

        -   关联: 老师和学生
        
            -   单向和双向
            
            ![image-20211028105544640](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211028105544640.png)

-   **包**

    -   将类分组成更高层次的单位
    -   用于描述包中存在的类以及包与包之间的依赖关系和泛化关系
    -   包与包之间允许建立依赖、泛化、细化等关系

-   **对象图**

    -   类图的实例

    -   对象图与类图具有几乎完全相同的表示形式，主要差别是对象的名字下面加一条线

        ![image-20211028105959755](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211028105959755.png)

### 进程视图

-   **状态图**

    ![image-20211028110313226](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211028110313226.png)

    ![image-20211028110344467](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211028110344467.png)

-   <span id="针对具体问题设计时序图">**顺序图**</span>

    -   作用
        -   描述了对象之间消息发送的先后顺序，强调时间顺序
        -   把用例表达的需求，转化为进一步、更加正式层次的精细表达
        -   用例常常被细化为一个或者更多的序列图

    ![image-20211028110836666](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211028110836666.png)

    -   要素
        -   纵坐标: 时间
        -   横坐标: 对象
        -   对象生命线
        -   对象间的通信: 用对象生命线之间的水平消息线来表示，消息箭头的形状表明消息的类型
        -   同步、异步、注释、约束
    -   组合片段
        -   解决交互执行的条件及方式
        -   常用的组合片段有：抉择、选项、循环、并行

-   **活动图**

    -   本质是一种流程图

    -   ![image-20211028112305183](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211028112305183.png)

    -   带泳道的活动图: 泳道表明每个活动是由哪些人或哪些部门负责完成

        ![image-20211028112208414](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211028112208414.png)

    -   带对象流的活动图: 对象流用带有箭头的虚线表示

        ![image-20211028112451582](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211028112451582.png)

-   **协作图**

    -   强调对象之间的合作关系
    -   时序图按照时间顺序布图，而协作图按照空间结构布图

    ![image-20211028112659755](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211028112659755.png)

### 实现视图

-   **构件图**

    -   表示系统中构件与构件之间，类或接口与构件之间的关系图
    -   构件图之间的关系表现为依赖关系，定义的类或接口与类之间的关系表现为依赖关系或实现关系

    ![image-20211028113209110](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211028113209110.png)

### 拓扑视图

-   **部署图**
    -   描述了系统运行时进行处理的节点以及在节点上活动的构件的配置
    -   可以很好的描述系统是如何部署的
    -   显示硬件中的软件以及各种连接协议
    -   平衡系统运行时的计算资源分布
    -   通过连接描述组织的硬件网络结构
    -   具有多种硬件和软件相关的系统运行模型

## 8.4 UML的使用准则

-   准则
    -   不要试图使用所有的图形和符号
    -   不要为每个事物都画一个模型
    -   应该分层次地画模型图
    -   模型应该具有协调性
    -   模型和模型元素的大小应该适中
-   UML扩展机制
    -   用户可以定义和使用自己的模型元素，给这些元素的变形加上新的语义
    -   三种扩展机制
        -   标签值
        -   约束
        -   构造型
-   UML应用领域
    -   需求分析
    -   设计
    -   构造
    -   测试

## 8.5 Rose软件及应用

# 10 面向对象的软件设计

## 10.1 面向对象分析

-   软件的分析
    -   理解
    -   表达
    -   验证
-   ![image-20211028113837247](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211028113837247.png)

-   对象模型的五个层次
    -   主题层(范畴层): 类边界，实例边界
    -   结构层: 实例连接
    -   类&对象层
    -   属性层
    -   服务层

## 10.2 第一步 建立对象模型

-   筛选出正确的类&对象
-   定义属性和方法
-   定义结构
    -   继承关系
    -   整体部分关系
    -   静态连接关系: 联系，用实例连接表示
    -   动态连接关系: 依赖，用消息连接表示

## 10.3 第二步 建立动态模型

-   行为分类
    -   系统行为
    -   对象自身的简单行为
    -   对象自身的复杂行为
-   发现服务的方法
-   编写脚本(操作过程，有正常操作流和异常的)
-   设想用户界面
-   画事件跟踪图
-   画状态图
-   从事件导出服务

## 10.4 第三步 建立功能模型

-   功能模型由一组数据流图组成

-   基本系统模型: 由一组数据流图组成

    ![image-20211028114747901](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211028114747901.png)

-   功能级数据流图: 把基本系统模型中单一的处理框分解成若干个处理框，以描
    述系统加工、变换数据的基本功能

    ![image-20211028114832517](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211028114832517.png)

## 10.5 面向对象设计

-   面向对象的设计准则

    -   模块化
    -   抽象
    -   信息隐蔽
    -   弱耦合
    -   强内聚
    -   可重用

-   设计模式类型

    ![image-20211028114942171](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211028114942171.png)

-   启发规则

-   系统设计
    -   将系统分解为子系统
    -   设计问题域子系统
    -   设计人--机交互子系统
    -   设计任务管理子系统
    -   设计数据管理子系统
    
-   对象设计

## 10.6 面向对象实现与测试

-   面向对象实现
    -   面向对象的程序设计语言
    -   面向对象的程序设计风格
-   面向对象测试
    -   面向对象的单元测试
    -   面向对象的集成测试
    -   面向对象的确认测试

# 软件工程复习内容

-   单选 10 \* 2
-   名词解释 5
-   简答题 5
-   综合题 3

## 第1章 软件与软件工程

1.  [软件的概念](#软件的概念)，[软件的特点](#软件的特点)，[软件发展的四个阶段](#软件发展的四个阶段)。
2.  [软件危机产生的原因](#软件危机产生的原因)，[解决软件危机的方法](#解决软件危机的方法)。
3.  [软件生命周期各阶段及其基本任务](#软件生命周期各阶段及其基本任务)
4.  软件开发过程模型：[瀑布模型](#瀑布模型)、[原型模型](#原型模型)、[螺旋模型](#螺旋模型)等几种模型的形式与特点及适用范围

## 第2章 需求分析基础

1.  [需求分析常用技术](#需求分析常用技术)
2.  [结构化分析方法](#结构化分析方法)
3.  [会画数据流图（DFD），分层数据流图、数据字典](#会画数据流图（DFD），分层数据流图、数据字典)
4.  [了解常用的需求分析方法](#了解常用的需求分析方法)

## 第3章 软件设计基础

1.  [软件体系结构概念](#软件体系结构概念)及[常见软件体系结构](#常见软件体系结构)：仓库模型、客户机/服务器、分布式对象结构、抽象机模型、
2.  [高内聚低耦合度的含义](#高内聚低耦合度的含义)
3.  熟悉[中心变换分析和事务分析](#中心变换分析和事务分析)
4.  [详细设计工具](#详细设计工具)（程序流程图、盒图与PAD图之间的转化）

## 第4章 程序设计语言和编码

1.   [结构化程序设计的主要特点](#结构化程序设计的主要特点)
2.  [影响程序效率的因素](#影响程序效率的因素)

## 第5章 软件测试

1.  [软件测试的目的和原则](#软件测试的目的和原则)
2.  [利用软件测试技术进行软件测试](#利用软件测试技术进行软件测试)
3.  **[白盒测试](#白盒测试)**
4.  **[黑盒测试](#黑盒测试)**

## 第6章 软件维护

1.  [四种维护的类型](#四种维护的类型)
2.  [软件维护的技术有哪几种](#软件维护的技术有哪几种)

## 第7章 面向对象的设计方法

1.  [面向对象技术的特点](#面向对象技术的特点)
2.  [面向对象的基本概念](#面向对象的基本概念)（对象、类、继承、消息、多态性）

## 第8章 UML统一建模语言

1.  [UML概念](#UML概念)
2.  [针对具体问题设计用例图](#针对具体问题设计用例图)
3.  [类与类之间的关系](#类与类之间的关系)
4.  [针对具体问题设计类图](#针对具体问题设计类图)
5.  [针对具体问题设计时序图](#针对具体问题设计时序图)

